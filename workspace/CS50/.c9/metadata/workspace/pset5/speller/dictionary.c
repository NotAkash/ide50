{"filter":false,"title":"dictionary.c","tooltip":"/pset5/speller/dictionary.c","undoManager":{"mark":100,"position":100,"stack":[[{"start":{"row":49,"column":23},"end":{"row":49,"column":24},"action":"remove","lines":["o"],"id":485}],[{"start":{"row":49,"column":22},"end":{"row":49,"column":23},"action":"remove","lines":["n"],"id":486}],[{"start":{"row":49,"column":22},"end":{"row":49,"column":23},"action":"insert","lines":["N"],"id":487}],[{"start":{"row":49,"column":23},"end":{"row":49,"column":24},"action":"insert","lines":["U"],"id":488}],[{"start":{"row":49,"column":24},"end":{"row":49,"column":25},"action":"insert","lines":["L"],"id":489}],[{"start":{"row":49,"column":25},"end":{"row":49,"column":26},"action":"insert","lines":["L"],"id":490}],[{"start":{"row":49,"column":27},"end":{"row":50,"column":0},"action":"insert","lines":["",""],"id":491},{"start":{"row":50,"column":0},"end":{"row":50,"column":8},"action":"insert","lines":["        "]}],[{"start":{"row":50,"column":8},"end":{"row":50,"column":9},"action":"insert","lines":["{"],"id":492}],[{"start":{"row":50,"column":9},"end":{"row":52,"column":9},"action":"insert","lines":["","            ","        }"],"id":493}],[{"start":{"row":51,"column":12},"end":{"row":51,"column":13},"action":"insert","lines":["u"],"id":494}],[{"start":{"row":51,"column":13},"end":{"row":51,"column":14},"action":"insert","lines":["n"],"id":495}],[{"start":{"row":51,"column":14},"end":{"row":51,"column":15},"action":"insert","lines":["l"],"id":496}],[{"start":{"row":51,"column":15},"end":{"row":51,"column":16},"action":"insert","lines":["o"],"id":497}],[{"start":{"row":51,"column":16},"end":{"row":51,"column":17},"action":"insert","lines":["a"],"id":498}],[{"start":{"row":51,"column":17},"end":{"row":51,"column":18},"action":"insert","lines":["d"],"id":499}],[{"start":{"row":51,"column":18},"end":{"row":51,"column":20},"action":"insert","lines":["()"],"id":500}],[{"start":{"row":51,"column":20},"end":{"row":52,"column":0},"action":"insert","lines":["",""],"id":501},{"start":{"row":52,"column":0},"end":{"row":52,"column":12},"action":"insert","lines":["            "]}],[{"start":{"row":52,"column":12},"end":{"row":52,"column":13},"action":"insert","lines":["r"],"id":502}],[{"start":{"row":52,"column":13},"end":{"row":52,"column":14},"action":"insert","lines":["e"],"id":503}],[{"start":{"row":52,"column":14},"end":{"row":52,"column":15},"action":"insert","lines":["t"],"id":504}],[{"start":{"row":52,"column":15},"end":{"row":52,"column":16},"action":"insert","lines":["u"],"id":505}],[{"start":{"row":53,"column":9},"end":{"row":53,"column":10},"action":"insert","lines":["r"],"id":506}],[{"start":{"row":53,"column":10},"end":{"row":53,"column":11},"action":"insert","lines":[" "],"id":507}],[{"start":{"row":53,"column":10},"end":{"row":53,"column":11},"action":"remove","lines":[" "],"id":508}],[{"start":{"row":53,"column":9},"end":{"row":53,"column":10},"action":"remove","lines":["r"],"id":509}],[{"start":{"row":52,"column":16},"end":{"row":52,"column":17},"action":"insert","lines":["r"],"id":510}],[{"start":{"row":52,"column":17},"end":{"row":52,"column":18},"action":"insert","lines":["n"],"id":511}],[{"start":{"row":52,"column":18},"end":{"row":52,"column":19},"action":"insert","lines":[" "],"id":512}],[{"start":{"row":52,"column":19},"end":{"row":52,"column":20},"action":"insert","lines":["f"],"id":513}],[{"start":{"row":52,"column":20},"end":{"row":52,"column":21},"action":"insert","lines":["a"],"id":514}],[{"start":{"row":52,"column":21},"end":{"row":52,"column":22},"action":"insert","lines":["l"],"id":515}],[{"start":{"row":52,"column":22},"end":{"row":52,"column":23},"action":"insert","lines":["s"],"id":516}],[{"start":{"row":52,"column":23},"end":{"row":52,"column":24},"action":"insert","lines":["e"],"id":517}],[{"start":{"row":52,"column":24},"end":{"row":52,"column":25},"action":"insert","lines":[";"],"id":518}],[{"start":{"row":53,"column":9},"end":{"row":54,"column":0},"action":"insert","lines":["",""],"id":519},{"start":{"row":54,"column":0},"end":{"row":54,"column":8},"action":"insert","lines":["        "]}],[{"start":{"row":54,"column":8},"end":{"row":54,"column":39},"action":"insert","lines":["  strcpy(new_node->word, word);"],"id":520}],[{"start":{"row":54,"column":9},"end":{"row":54,"column":10},"action":"remove","lines":[" "],"id":521}],[{"start":{"row":54,"column":8},"end":{"row":54,"column":9},"action":"remove","lines":[" "],"id":522}],[{"start":{"row":54,"column":37},"end":{"row":55,"column":0},"action":"insert","lines":["",""],"id":523},{"start":{"row":55,"column":0},"end":{"row":55,"column":8},"action":"insert","lines":["        "]}],[{"start":{"row":44,"column":8},"end":{"row":44,"column":9},"action":"remove","lines":["o"],"id":524}],[{"start":{"row":46,"column":10},"end":{"row":46,"column":11},"action":"remove","lines":[" "],"id":525}],[{"start":{"row":51,"column":20},"end":{"row":51,"column":21},"action":"insert","lines":[";"],"id":526}],[{"start":{"row":32,"column":1},"end":{"row":33,"column":0},"action":"insert","lines":["",""],"id":528},{"start":{"row":33,"column":0},"end":{"row":33,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":33,"column":4},"end":{"row":34,"column":0},"action":"insert","lines":["",""],"id":529},{"start":{"row":34,"column":0},"end":{"row":34,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":34,"column":4},"end":{"row":35,"column":0},"action":"insert","lines":["",""],"id":530},{"start":{"row":35,"column":0},"end":{"row":35,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":35,"column":4},"end":{"row":36,"column":0},"action":"insert","lines":["",""],"id":531},{"start":{"row":36,"column":0},"end":{"row":36,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":36,"column":4},"end":{"row":37,"column":0},"action":"insert","lines":["",""],"id":532},{"start":{"row":37,"column":0},"end":{"row":37,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":37,"column":4},"end":{"row":38,"column":0},"action":"insert","lines":["",""],"id":533},{"start":{"row":38,"column":0},"end":{"row":38,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":38,"column":4},"end":{"row":39,"column":0},"action":"insert","lines":["",""],"id":534},{"start":{"row":39,"column":0},"end":{"row":39,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":34,"column":4},"end":{"row":44,"column":0},"action":"insert","lines":[" FILE* dictionaryFile = fopen(dictionary, \"r\");","    if (dictionaryFile == NULL)","    {","        printf(\"Could not open file.\\n\");","        return false;","    }","    first = createNode();","    ","    unsigned int c = 0;","    node* nextNode = first;",""],"id":535}],[{"start":{"row":34,"column":4},"end":{"row":34,"column":5},"action":"remove","lines":[" "],"id":536}],[{"start":{"row":41,"column":0},"end":{"row":41,"column":4},"action":"remove","lines":["    "],"id":537}],[{"start":{"row":40,"column":25},"end":{"row":41,"column":0},"action":"remove","lines":["",""],"id":538}],[{"start":{"row":16,"column":0},"end":{"row":29,"column":27},"action":"remove","lines":["typedef struct node","{","    bool isleaf; ","    struct node* childs[27]; ","}","node;","","node* makeNode(void)","{","    return (node*) malloc(sizeof(node));","}","","node* root;","unsigned int wordcount = 0;"],"id":539}],[{"start":{"row":20,"column":4},"end":{"row":60,"column":17},"action":"remove","lines":["","    FILE* dictionaryFile = fopen(dictionary, \"r\");","    if (dictionaryFile == NULL)","    {","        printf(\"Could not open file.\\n\");","        return false;","    }","    first = createNode();","    unsigned int c = 0;","    node* nextNode = first;","","    ","    ","    ","    ","    ","    typedef struct node","    {","        ","        char word[LENGTH +1];","        struct node *next;","    }","    node;","    ","    node *node1 = malloc(sizeof(node));","    node *node2 = malloc(sizeof(node));         ","    strcpy(node1->word, \"Hello\");","    strcpy(node2->word, \"World\");","    node1->next= node2;","    while(fscanf(file, \"%s\", word) != EOF)","    {","        node *new_node = malloc(sizeof(node));","        if (new_node==NULL)","        {","            unload();","            return false;","        }","        strcpy(new_node->word, word);","        ","    }","    return false;"],"id":540}],[{"start":{"row":20,"column":4},"end":{"row":20,"column":5},"action":"insert","lines":["f"],"id":541}],[{"start":{"row":20,"column":5},"end":{"row":20,"column":6},"action":"insert","lines":["c"],"id":542}],[{"start":{"row":20,"column":6},"end":{"row":20,"column":7},"action":"insert","lines":["a"],"id":543}],[{"start":{"row":20,"column":6},"end":{"row":20,"column":7},"action":"remove","lines":["a"],"id":544}],[{"start":{"row":20,"column":5},"end":{"row":20,"column":6},"action":"remove","lines":["c"],"id":545}],[{"start":{"row":20,"column":5},"end":{"row":20,"column":6},"action":"insert","lines":["s"],"id":546}],[{"start":{"row":20,"column":6},"end":{"row":20,"column":7},"action":"insert","lines":["c"],"id":547}],[{"start":{"row":20,"column":7},"end":{"row":20,"column":8},"action":"insert","lines":["a"],"id":548}],[{"start":{"row":20,"column":8},"end":{"row":20,"column":9},"action":"insert","lines":["n"],"id":549}],[{"start":{"row":20,"column":9},"end":{"row":20,"column":10},"action":"insert","lines":["f"],"id":550}],[{"start":{"row":20,"column":10},"end":{"row":20,"column":12},"action":"insert","lines":["()"],"id":551}],[{"start":{"row":20,"column":4},"end":{"row":20,"column":12},"action":"remove","lines":["fscanf()"],"id":553}],[{"start":{"row":20,"column":4},"end":{"row":20,"column":5},"action":"insert","lines":["t"],"id":554}],[{"start":{"row":0,"column":0},"end":{"row":49,"column":0},"action":"remove","lines":[" /**"," * dictionary.c"," */","","#include <stdbool.h>","#include <stdio.h>","#include <cs50.h>","#include <string.h>","#include <ctype.h>","","#include \"dictionary.h\"","","","/**"," * Loads dictionary into memory. Returns true if successful else false."," */","","","bool load(const char *dictionary)","{","    t","}","","/**"," * Returns true if word is in dictionary else false."," */","","bool check(const char *word)","{","","}","","/**"," * Returns number of words in dictionary if loaded else 0 if not yet loaded."," */","unsigned int size(void)","{","    // TODO","    return 0;","}","","/**"," * Unloads dictionary from memory. Returns true if successful else false."," */","bool unload(void)","{","    // TODO","    return false;","}",""],"id":696},{"start":{"row":0,"column":0},"end":{"row":184,"column":1},"action":"insert","lines":["/**"," * dictionary.c"," *"," * Computer Science 50"," * Problem Set 5"," *"," * Implements a dictionary's functionality."," */","","#include \"dictionary.h\"","","// define struct for value-pointer pair, i.e., a node","typedef struct node","{","    char word[LENGTH + 1];","    struct node* next;","}","node;","","// create array of pointer-to-nodes of size HASHTABLE_SIZE","node* hashtable[HASHTABLE_SIZE];","","// global variable for tracking dictionary size","unsigned int word_count = 0;","","// global boolean for tracking load/unload dictionary operations","bool loaded = false;","","/**"," * Hash function via reddit user delipity:"," * https://www.reddit.com/r/cs50/comments/1x6vc8/pset6_trie_vs_hashtable/cf9nlkn"," */","int hash_it(char* needs_hashing)","{","    unsigned int hash = 0;","    for (int i=0, n=strlen(needs_hashing); i<n; i++)","        hash = (hash << 2) ^ needs_hashing[i];","    return hash % HASHTABLE_SIZE;","}","","/**"," * Returns true if word is in dictionary else false. Case-insensitive."," * Assume that check is only passed strings with alphabetical characters and/or"," * apostrophes."," */","bool check(const char* word)","{","    // create char array to store copy of word","    // word is a const char* and non-read actions cannot be performed on it","    int len = strlen(word);","    char word_copy[len + 1];","    ","    // convert word to lowercase and store it in word_copy","    for (int i = 0; i < len; i++)","    {","       word_copy[i] = tolower(word[i]);","    }","    ","    // add null terminator to end of char array","    word_copy[len] = '\\0';","    ","    // get hash value (a.k.a. bucket)","    int h = hash_it(word_copy);","    ","    // assign cursor node to the first node of the bucket","    node* cursor = hashtable[h];","    ","    // check until the end of the linked list","    while (cursor != NULL)","    {","        if (strcmp(cursor->word, word_copy) == 0)","        {","            // word is in dictionary","            return true;","        }","        else","        {","            // check next node","            cursor = cursor->next;","        }","    }","    return false;","}","","/**"," * Loads dictionary into memory. Stores words in hash table. Returns true if"," * successful else false."," */","bool load(const char* dictionary)","{","    // make all hash table elements NULL","    for (int i = 0; i < HASHTABLE_SIZE; i++)","    {","        hashtable[i] = NULL;","    }","    ","    // open dictionary","    FILE* fp = fopen(dictionary, \"r\");","    if (fp == NULL)","    {","        printf(\"Could not open dictionary.\\n\");","        return false;","    }","","    while (true)","    {","        // malloc a node for each new word","        node* new_node = malloc(sizeof(node));","        if (new_node == NULL)","        {","            printf(\"Could not malloc a new node.\\n\");","            return false;","        }","        ","        // read a word from the dictionary and store it in new_node->word","        fscanf(fp, \"%s\", new_node->word);","        new_node->next = NULL;","        ","        if (feof(fp))","        {","            // hit end of file","            free(new_node);","            break;","        }","","        word_count++;","        ","        // hashtable[h] is a pointer to a key-value pair","        int h = hash_it(new_node->word);","        node* head = hashtable[h];","        ","        // if bucket is empty, insert the first node","        if (head == NULL)","        {","            hashtable[h] = new_node;","        }","        // if bucket is not empty, attach node to front of list","        // design choice: unsorted linked list to minimize load time rather","        // than sorted linked list to minimize check time","        else","        {","            new_node->next = hashtable[h];","            hashtable[h] = new_node;","        }","    }","    // close dictionary","    fclose(fp);","    loaded = true;","    return true;","}","","/**"," * Returns number of words in dictionary if loaded else 0 if not yet loaded."," */","unsigned int size(void)","{","    if (loaded)","    {","        return word_count;","    }","    else","    {","        return 0;","    }","}","","/**"," * Unloads dictionary from memory.  Returns true if successful else false."," */","bool unload(void)","{","    for (int i = 0; i < HASHTABLE_SIZE; i++)","    {","        node* cursor = hashtable[i];","        while (cursor != NULL)","        {","            // maintain connection to linked list using temp","            node* temp = cursor;","            cursor = cursor->next;","            free(temp);","        }","    }","    loaded = false;","    return true;","}"]}],[{"start":{"row":0,"column":0},"end":{"row":184,"column":1},"action":"remove","lines":["/**"," * dictionary.c"," *"," * Computer Science 50"," * Problem Set 5"," *"," * Implements a dictionary's functionality."," */","","#include \"dictionary.h\"","","// define struct for value-pointer pair, i.e., a node","typedef struct node","{","    char word[LENGTH + 1];","    struct node* next;","}","node;","","// create array of pointer-to-nodes of size HASHTABLE_SIZE","node* hashtable[HASHTABLE_SIZE];","","// global variable for tracking dictionary size","unsigned int word_count = 0;","","// global boolean for tracking load/unload dictionary operations","bool loaded = false;","","/**"," * Hash function via reddit user delipity:"," * https://www.reddit.com/r/cs50/comments/1x6vc8/pset6_trie_vs_hashtable/cf9nlkn"," */","int hash_it(char* needs_hashing)","{","    unsigned int hash = 0;","    for (int i=0, n=strlen(needs_hashing); i<n; i++)","        hash = (hash << 2) ^ needs_hashing[i];","    return hash % HASHTABLE_SIZE;","}","","/**"," * Returns true if word is in dictionary else false. Case-insensitive."," * Assume that check is only passed strings with alphabetical characters and/or"," * apostrophes."," */","bool check(const char* word)","{","    // create char array to store copy of word","    // word is a const char* and non-read actions cannot be performed on it","    int len = strlen(word);","    char word_copy[len + 1];","    ","    // convert word to lowercase and store it in word_copy","    for (int i = 0; i < len; i++)","    {","       word_copy[i] = tolower(word[i]);","    }","    ","    // add null terminator to end of char array","    word_copy[len] = '\\0';","    ","    // get hash value (a.k.a. bucket)","    int h = hash_it(word_copy);","    ","    // assign cursor node to the first node of the bucket","    node* cursor = hashtable[h];","    ","    // check until the end of the linked list","    while (cursor != NULL)","    {","        if (strcmp(cursor->word, word_copy) == 0)","        {","            // word is in dictionary","            return true;","        }","        else","        {","            // check next node","            cursor = cursor->next;","        }","    }","    return false;","}","","/**"," * Loads dictionary into memory. Stores words in hash table. Returns true if"," * successful else false."," */","bool load(const char* dictionary)","{","    // make all hash table elements NULL","    for (int i = 0; i < HASHTABLE_SIZE; i++)","    {","        hashtable[i] = NULL;","    }","    ","    // open dictionary","    FILE* fp = fopen(dictionary, \"r\");","    if (fp == NULL)","    {","        printf(\"Could not open dictionary.\\n\");","        return false;","    }","","    while (true)","    {","        // malloc a node for each new word","        node* new_node = malloc(sizeof(node));","        if (new_node == NULL)","        {","            printf(\"Could not malloc a new node.\\n\");","            return false;","        }","        ","        // read a word from the dictionary and store it in new_node->word","        fscanf(fp, \"%s\", new_node->word);","        new_node->next = NULL;","        ","        if (feof(fp))","        {","            // hit end of file","            free(new_node);","            break;","        }","","        word_count++;","        ","        // hashtable[h] is a pointer to a key-value pair","        int h = hash_it(new_node->word);","        node* head = hashtable[h];","        ","        // if bucket is empty, insert the first node","        if (head == NULL)","        {","            hashtable[h] = new_node;","        }","        // if bucket is not empty, attach node to front of list","        // design choice: unsorted linked list to minimize load time rather","        // than sorted linked list to minimize check time","        else","        {","            new_node->next = hashtable[h];","            hashtable[h] = new_node;","        }","    }","    // close dictionary","    fclose(fp);","    loaded = true;","    return true;","}","","/**"," * Returns number of words in dictionary if loaded else 0 if not yet loaded."," */","unsigned int size(void)","{","    if (loaded)","    {","        return word_count;","    }","    else","    {","        return 0;","    }","}","","/**"," * Unloads dictionary from memory.  Returns true if successful else false."," */","bool unload(void)","{","    for (int i = 0; i < HASHTABLE_SIZE; i++)","    {","        node* cursor = hashtable[i];","        while (cursor != NULL)","        {","            // maintain connection to linked list using temp","            node* temp = cursor;","            cursor = cursor->next;","            free(temp);","        }","    }","    loaded = false;","    return true;","}"],"id":697},{"start":{"row":0,"column":0},"end":{"row":184,"column":1},"action":"insert","lines":["/**"," * dictionary.c"," *"," * Computer Science 50"," * Problem Set 5"," *"," * Implements a dictionary's functionality."," */","","#include \"dictionary.h\"","","// define struct for value-pointer pair, i.e., a node","typedef struct node","{","    char word[LENGTH + 1];","    struct node* next;","}","node;","","// create array of pointer-to-nodes of size HASHTABLE_SIZE","node* hashtable[HASHTABLE_SIZE];","","// global variable for tracking dictionary size","unsigned int word_count = 0;","","// global boolean for tracking load/unload dictionary operations","bool loaded = false;","","/**"," * Hash function via reddit user delipity:"," * https://www.reddit.com/r/cs50/comments/1x6vc8/pset6_trie_vs_hashtable/cf9nlkn"," */","int hash_it(char* needs_hashing)","{","    unsigned int hash = 0;","    for (int i=0, n=strlen(needs_hashing); i<n; i++)","        hash = (hash << 2) ^ needs_hashing[i];","    return hash % HASHTABLE_SIZE;","}","","/**"," * Returns true if word is in dictionary else false. Case-insensitive."," * Assume that check is only passed strings with alphabetical characters and/or"," * apostrophes."," */","bool check(const char* word)","{","    // create char array to store copy of word","    // word is a const char* and non-read actions cannot be performed on it","    int len = strlen(word);","    char word_copy[len + 1];","    ","    // convert word to lowercase and store it in word_copy","    for (int i = 0; i < len; i++)","    {","       word_copy[i] = tolower(word[i]);","    }","    ","    // add null terminator to end of char array","    word_copy[len] = '\\0';","    ","    // get hash value (a.k.a. bucket)","    int h = hash_it(word_copy);","    ","    // assign cursor node to the first node of the bucket","    node* cursor = hashtable[h];","    ","    // check until the end of the linked list","    while (cursor != NULL)","    {","        if (strcmp(cursor->word, word_copy) == 0)","        {","            // word is in dictionary","            return true;","        }","        else","        {","            // check next node","            cursor = cursor->next;","        }","    }","    return false;","}","","/**"," * Loads dictionary into memory. Stores words in hash table. Returns true if"," * successful else false."," */","bool load(const char* dictionary)","{","    // make all hash table elements NULL","    for (int i = 0; i < HASHTABLE_SIZE; i++)","    {","        hashtable[i] = NULL;","    }","    ","    // open dictionary","    FILE* fp = fopen(dictionary, \"r\");","    if (fp == NULL)","    {","        printf(\"Could not open dictionary.\\n\");","        return false;","    }","","    while (true)","    {","        // malloc a node for each new word","        node* new_node = malloc(sizeof(node));","        if (new_node == NULL)","        {","            printf(\"Could not malloc a new node.\\n\");","            return false;","        }","        ","        // read a word from the dictionary and store it in new_node->word","        fscanf(fp, \"%s\", new_node->word);","        new_node->next = NULL;","        ","        if (feof(fp))","        {","            // hit end of file","            free(new_node);","            break;","        }","","        word_count++;","        ","        // hashtable[h] is a pointer to a key-value pair","        int h = hash_it(new_node->word);","        node* head = hashtable[h];","        ","        // if bucket is empty, insert the first node","        if (head == NULL)","        {","            hashtable[h] = new_node;","        }","        // if bucket is not empty, attach node to front of list","        // design choice: unsorted linked list to minimize load time rather","        // than sorted linked list to minimize check time","        else","        {","            new_node->next = hashtable[h];","            hashtable[h] = new_node;","        }","    }","    // close dictionary","    fclose(fp);","    loaded = true;","    return true;","}","","/**"," * Returns number of words in dictionary if loaded else 0 if not yet loaded."," */","unsigned int size(void)","{","    if (loaded)","    {","        return word_count;","    }","    else","    {","        return 0;","    }","}","","/**"," * Unloads dictionary from memory.  Returns true if successful else false."," */","bool unload(void)","{","    for (int i = 0; i < HASHTABLE_SIZE; i++)","    {","        node* cursor = hashtable[i];","        while (cursor != NULL)","        {","            // maintain connection to linked list using temp","            node* temp = cursor;","            cursor = cursor->next;","            free(temp);","        }","    }","    loaded = false;","    return true;","}"]}],[{"start":{"row":0,"column":0},"end":{"row":184,"column":1},"action":"remove","lines":["/**"," * dictionary.c"," *"," * Computer Science 50"," * Problem Set 5"," *"," * Implements a dictionary's functionality."," */","","#include \"dictionary.h\"","","// define struct for value-pointer pair, i.e., a node","typedef struct node","{","    char word[LENGTH + 1];","    struct node* next;","}","node;","","// create array of pointer-to-nodes of size HASHTABLE_SIZE","node* hashtable[HASHTABLE_SIZE];","","// global variable for tracking dictionary size","unsigned int word_count = 0;","","// global boolean for tracking load/unload dictionary operations","bool loaded = false;","","/**"," * Hash function via reddit user delipity:"," * https://www.reddit.com/r/cs50/comments/1x6vc8/pset6_trie_vs_hashtable/cf9nlkn"," */","int hash_it(char* needs_hashing)","{","    unsigned int hash = 0;","    for (int i=0, n=strlen(needs_hashing); i<n; i++)","        hash = (hash << 2) ^ needs_hashing[i];","    return hash % HASHTABLE_SIZE;","}","","/**"," * Returns true if word is in dictionary else false. Case-insensitive."," * Assume that check is only passed strings with alphabetical characters and/or"," * apostrophes."," */","bool check(const char* word)","{","    // create char array to store copy of word","    // word is a const char* and non-read actions cannot be performed on it","    int len = strlen(word);","    char word_copy[len + 1];","    ","    // convert word to lowercase and store it in word_copy","    for (int i = 0; i < len; i++)","    {","       word_copy[i] = tolower(word[i]);","    }","    ","    // add null terminator to end of char array","    word_copy[len] = '\\0';","    ","    // get hash value (a.k.a. bucket)","    int h = hash_it(word_copy);","    ","    // assign cursor node to the first node of the bucket","    node* cursor = hashtable[h];","    ","    // check until the end of the linked list","    while (cursor != NULL)","    {","        if (strcmp(cursor->word, word_copy) == 0)","        {","            // word is in dictionary","            return true;","        }","        else","        {","            // check next node","            cursor = cursor->next;","        }","    }","    return false;","}","","/**"," * Loads dictionary into memory. Stores words in hash table. Returns true if"," * successful else false."," */","bool load(const char* dictionary)","{","    // make all hash table elements NULL","    for (int i = 0; i < HASHTABLE_SIZE; i++)","    {","        hashtable[i] = NULL;","    }","    ","    // open dictionary","    FILE* fp = fopen(dictionary, \"r\");","    if (fp == NULL)","    {","        printf(\"Could not open dictionary.\\n\");","        return false;","    }","","    while (true)","    {","        // malloc a node for each new word","        node* new_node = malloc(sizeof(node));","        if (new_node == NULL)","        {","            printf(\"Could not malloc a new node.\\n\");","            return false;","        }","        ","        // read a word from the dictionary and store it in new_node->word","        fscanf(fp, \"%s\", new_node->word);","        new_node->next = NULL;","        ","        if (feof(fp))","        {","            // hit end of file","            free(new_node);","            break;","        }","","        word_count++;","        ","        // hashtable[h] is a pointer to a key-value pair","        int h = hash_it(new_node->word);","        node* head = hashtable[h];","        ","        // if bucket is empty, insert the first node","        if (head == NULL)","        {","            hashtable[h] = new_node;","        }","        // if bucket is not empty, attach node to front of list","        // design choice: unsorted linked list to minimize load time rather","        // than sorted linked list to minimize check time","        else","        {","            new_node->next = hashtable[h];","            hashtable[h] = new_node;","        }","    }","    // close dictionary","    fclose(fp);","    loaded = true;","    return true;","}","","/**"," * Returns number of words in dictionary if loaded else 0 if not yet loaded."," */","unsigned int size(void)","{","    if (loaded)","    {","        return word_count;","    }","    else","    {","        return 0;","    }","}","","/**"," * Unloads dictionary from memory.  Returns true if successful else false."," */","bool unload(void)","{","    for (int i = 0; i < HASHTABLE_SIZE; i++)","    {","        node* cursor = hashtable[i];","        while (cursor != NULL)","        {","            // maintain connection to linked list using temp","            node* temp = cursor;","            cursor = cursor->next;","            free(temp);","        }","    }","    loaded = false;","    return true;","}"],"id":698},{"start":{"row":0,"column":0},"end":{"row":189,"column":1},"action":"insert","lines":["#include <stdbool.h>","#include <stdio.h>","#include <ctype.h>","#include <stdlib.h>","#include <string.h>","#include <math.h>","","#include \"dictionary.h\"","","","// total size of hash table","#define SIZE 100000","","// make the nodes for list","typedef struct node","{","    char word[LENGTH+1];","    struct node* next;","}","node;","","// make hashtable","node* hashtable[SIZE] = {NULL};","","// make hash function","int hash (const char* word)","{","    int hash = 0;","    int n;","    for (int i = 0; word[i] != '\\0'; i++)","    {","        // check  if word[i] is letter","        if(isalpha(word[i]))","            n = word [i] - 'a' + 1;","","","        else","            n = 27;","           //left shift","            hash = ((hash << 3) + n) % SIZE;","    }","    return hash;","}","","// create global variable to count size","int dictionarySize = 0;","","/**"," * Loads dictionary into memory.  Returns true if successful else false."," */","bool load(const char* dictionary)","{","    // TODO","    // opens dictionary","    FILE* file = fopen(dictionary, \"r\");","    if (file == NULL)","        return false;","        fprintf(stderr, \"File does not exist!\\n\");","    // create an array for word to be stored in","    char word[LENGTH+1];","","    // scan through the file, get each word into the hash table","    while (fscanf(file, \"%s\\n\", word)!= EOF)","    {","","        dictionarySize++;","","        // get memory value for new word","        node* newWord = malloc(sizeof(node));","","        // put word in the new node","        strcpy(newWord->word, word);","","        // look for array index for word should go","        int index = hash(word);","","        // if index of hash table empty","        if (hashtable[index] == NULL)","        {","            hashtable[index] = newWord;","            newWord->next = NULL;","        }","","        // C","        else","        {","            newWord->next = hashtable[index];","            hashtable[index] = newWord;","        }","    }","","","    fclose(file);","","    // if successful","    return true;","}","","/**"," * Returns true if word is in dictionary else false."," */","bool check(const char* word)","{","    // TODO","    // make variable for lower-cased  words","    char temp[LENGTH + 1];","    int len = strlen(word);","    for(int i = 0; i < len; i++)","        temp[i] = tolower(word[i]);","    temp[len] = '\\0';","","    // look for array index for word should go","    int index = hash(temp);","","    // if index of hash table empty","    if (hashtable[index] == NULL)","    {","        return false;","    }","","    // make the cursor to compare words","    node* cursor = hashtable[index];","","    // if hash table is not empty at index, iterate through words and compare","    while (cursor != NULL)","    {","        if (strcmp(temp, cursor->word) == 0)","        {","            return true;","        }","        cursor = cursor->next;","    }","","    // if you don't find the word","    return false;","}","","/**"," * Returns number of words in dictionary if loaded else 0 if not yet loaded."," */","unsigned int size(void)","{","    // TODO","    // if dictionary is loaded, return number of words","    if (dictionarySize > 0)","    {","        return dictionarySize;","    }","","    // if dictionary hasn't been loaded","    else","        return 0;","}","","/**"," * Unloads dictionary from memory.  Returns true if successful else false."," */","bool unload(void)","{","    // TODO","    // create a variable to go through index","    int index = 0;","","    // iterate through entire hashtable array","    while (index < SIZE)","    {","        // if hashtable is empty at index, go to next index","        if (hashtable[index] == NULL)","        {","            index++;","        }","","        // if hashtable is not empty, iterate through nodes and start freeing","        else","        {","            while(hashtable[index] != NULL)","            {","                node* cursor = hashtable[index];","                hashtable[index] = cursor->next;","                free(cursor);","            }","","            // once hashtable is empty at index, go to next index","            index++;","        }","    }","","    // return true if successful","    return true;","}"]}],[{"start":{"row":11,"column":19},"end":{"row":11,"column":20},"action":"insert","lines":[" "],"id":699}],[{"start":{"row":11,"column":19},"end":{"row":11,"column":20},"action":"remove","lines":[" "],"id":700}],[{"start":{"row":10,"column":26},"end":{"row":10,"column":27},"action":"remove","lines":["e"],"id":701}],[{"start":{"row":10,"column":25},"end":{"row":10,"column":26},"action":"remove","lines":["l"],"id":702}],[{"start":{"row":10,"column":24},"end":{"row":10,"column":25},"action":"remove","lines":["b"],"id":703}],[{"start":{"row":10,"column":23},"end":{"row":10,"column":24},"action":"remove","lines":["a"],"id":704}],[{"start":{"row":10,"column":22},"end":{"row":10,"column":23},"action":"remove","lines":["t"],"id":705}],[{"start":{"row":10,"column":21},"end":{"row":10,"column":22},"action":"remove","lines":[" "],"id":706}],[{"start":{"row":10,"column":20},"end":{"row":10,"column":21},"action":"remove","lines":["h"],"id":707}],[{"start":{"row":10,"column":19},"end":{"row":10,"column":20},"action":"remove","lines":["s"],"id":708}],[{"start":{"row":10,"column":18},"end":{"row":10,"column":19},"action":"remove","lines":["a"],"id":709}],[{"start":{"row":10,"column":17},"end":{"row":10,"column":18},"action":"remove","lines":["h"],"id":710}],[{"start":{"row":10,"column":17},"end":{"row":10,"column":18},"action":"insert","lines":["t"],"id":711}],[{"start":{"row":10,"column":18},"end":{"row":10,"column":19},"action":"insert","lines":["a"],"id":712}],[{"start":{"row":10,"column":19},"end":{"row":10,"column":20},"action":"insert","lines":["b"],"id":713}],[{"start":{"row":10,"column":20},"end":{"row":10,"column":21},"action":"insert","lines":["l"],"id":714}],[{"start":{"row":10,"column":21},"end":{"row":10,"column":22},"action":"insert","lines":["e"],"id":715}],[{"start":{"row":5,"column":0},"end":{"row":5,"column":17},"action":"remove","lines":["#include <math.h>"],"id":716}],[{"start":{"row":0,"column":0},"end":{"row":1,"column":0},"action":"insert","lines":["",""],"id":717}],[{"start":{"row":0,"column":0},"end":{"row":0,"column":17},"action":"insert","lines":["#include <math.h>"],"id":718}],[{"start":{"row":4,"column":0},"end":{"row":4,"column":19},"action":"remove","lines":["#include <stdlib.h>"],"id":719}],[{"start":{"row":3,"column":0},"end":{"row":4,"column":0},"action":"insert","lines":["",""],"id":720}],[{"start":{"row":3,"column":0},"end":{"row":3,"column":19},"action":"insert","lines":["#include <stdlib.h>"],"id":721}],[{"start":{"row":4,"column":18},"end":{"row":5,"column":0},"action":"remove","lines":["",""],"id":722}],[{"start":{"row":5,"column":19},"end":{"row":6,"column":0},"action":"remove","lines":["",""],"id":723}],[{"start":{"row":21,"column":6},"end":{"row":21,"column":7},"action":"remove","lines":["e"],"id":724}],[{"start":{"row":21,"column":5},"end":{"row":21,"column":6},"action":"remove","lines":["k"],"id":725}],[{"start":{"row":21,"column":4},"end":{"row":21,"column":5},"action":"remove","lines":["a"],"id":726}],[{"start":{"row":21,"column":3},"end":{"row":21,"column":4},"action":"remove","lines":["m"],"id":727}],[{"start":{"row":21,"column":2},"end":{"row":21,"column":3},"action":"remove","lines":[" "],"id":728}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":23,"column":0},"end":{"row":23,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1512044739283,"hash":"f00f634552671585366d75bba40a232733d779a3"}